\documentclass{cake-classes/short-report-fa}
\newcommand{\کیک}{مجموعهٔ کیکْ روباتیک}
\begin{document}
\درج‌عنوان‌سند

\قسمت{مقدمه}
در این گزارش کوتاه، شرح پیشرفت پروژه در زمستان ۱۴۰۰ آورده شده است.

\قسمت{پایدارسازی زیرسیستم شبیه‌سازی ابری}
زیر سیستم شبیه‌سازی ابری که در آذر ماه توسعه داده شده بود، دچار ایراداتی بود که در زمستان مرتفع شد و به پایداری بیشتر سیستم انجامید. در ادامه این موارد شرح داده شده است.
\زیرقسمت{رفع مشکل گردش ربات پیشفرض}
ربات پیشفرض مورد استفاده در شبیه‌سازی به درستی گردش نمی‌کرد که مشکل آن ریشه‌یابی و حل شد. مشکل در مقدار یکی از پارامترهای فایل \مل{URDF} بود که از مرجعی دیگر (\مل{ROS Nav Stack}) تهیه شده بود. ما پس از رفع مشکل در پروژهٔ خود، این اشکال را به مرجع اطلاع دادیم و اصلاحات لازم در آنجا نیز اعمال شد.\پانویس{https://github.com/ros-planning/navigation.ros.org/pull/240}

\زیرقسمت{حذف \مل{rosboard}}
در اواخر پاییز تصمیم گرفته شد که برای عیب یابی ربات‌ها، یک نسخه از داشبورد آنلاین \مل{rosboard} همراه با کتابخانهٔ ما (\مل{crl}) روی ربات نصب شود. بدین ترتیب این امکان پیدا می‌شد که با داشتن \مل{ip} ربات و اتصال به پورت مناسب، وضعیت تاپیک‌های راس پایش شود.

در زمستان تصمیم گرفته شد که از این کار صرف نظر شود و به جای آن از سرویس \مل{devices} استفاده شود. این سرویس به طور مفصل در زیرقسمت بعدی گزارش تشریح شده است. مزایای اصلی سرویس \مل{devices} در برابر \مل{rosboard} عبارت‌اند از:
\شروع{شمارش}
\فقره دیگر نیازی نیست \مل{ip} ربات را بدانیم یا حتی ربات \مل{ip} ثابت داشته باشد.
\فقره امکان ارسال \مل{log} از ربات به ابر وجود دارد.
\فقره امکان ارسال \مل{command} از ابر به ربات وجود دارد (مانند \مل{restart}).
\فقره سرویس \مل{devices} با معماری جدید از هسته مستقل است. در حالت قبلی، \مل{rosboard} بخشی از هسته می‌شد که محدودیت‌هایی برای آن ایجاد می‌کرد.
\پایان{شمارش}

\زیرقسمت{پایدارسازی نقطه‌شروع}
در بعضی موارد نقطه شروع ربات داخل زمین و... بود که با اضافه نمودن پشتیبانی از کانفیگ‌فایل در سرویس \مل{launcher} موجود در ایمیج \مل{sim}، مشکل حل شد.

\زیرقسمت{پایدارسازی لحظهٔ شروع}
این مشکل وجود داشت که شروع شبیه‌سازی چند دقیقه طول می‌کشید. این باعث می‌شد کاربر موقتا مشغول به کار دیگری شود و بازگردد و ببیند شبیه‌سازی پیش از بازگشت او شروع شده و او نتوانسته حرکت ربات را ببیند. برای رفع این مشکل، هم در سرویس \مل{sim} و هم در هسته کدی اضافه شد که در صورت تشخیص محیط شبیه‌سازی، اجرا را تا لحظه گرفتن دستور از کاربر متوقف کند.

\قسمت{استفاده از ایمیج‌های استاتیک برای ربات‌ها}
یک قدم اشتباه که در پاییز برداشته شد، استفاده از ایمیج‌های دینامیک برای ربات‌ها بود. تصمیم بدین صورت بود که هرگاه کدی برای ربات نوشته می‌شود، پیش‌نیازهای آن در کنار کد توسط یک سرویس موسوم به \مل{bundler} به داکرفایل تبدیل شوند و توسط یک سرویس \مل{builder}، ایمیج مورد نظر ساخته شده و به ربات فرستاده شود. منطق پشت این تصمیم این بود که این کار باعث می‌شود کتابخانه‌های پیش‌نیاز تنها در صورتی نصب شوند که ربات به آنها نیاز دارد و بدین ترتیب حجم ایمیج‌های داکر پایین بیاید.

با پیاده‌سازی این طراحی، مشخص شد که مشکلات ایمیج‌های دینامیکی بیشتر از فواید آن‌هاست. برای مثال، بیلد کردن ایمیج‌ها نیاز به منابع و زمان دارد و پیچیدگی را نیز افزایش می‌دهد. در واقع، هر بار اجرای شبیه‌سازی حدود ۵ دقیقه طول می‌کشید.

برای رفع مشکل تصمیم گرفته شد قابلیتی که آن را \مل{Hot-reload} نامیدیم پیاده‌سازی شود. این قابلیت بدین صورت بود که هنگامی که یک شبیه‌سازی در حال اجرا بود، اگر کاربر کد را تغییر می‌داد، بجای بیلد مجدد ایمیج، تنها فایل کد تغییر داده می‌شد و پراسس پایتون بسته و دوباره اجرا می‌شد. این فرایند که پیاده‌سازی آن با پیچیدگی همراه بود، با موفقیت زمان انتظار بین دو شبیه‌سازی متوالی را کاهش داد. با این حال، زمان باز شدن اولین شبیه‌سازی همچنان بالا بود و باعث می‌شد اگر کاربری به اشتباه و یا برای صرفه‌جویی در هزینه‌ها شبیه‌سازی را ببندد، مجبور باشد برای اجرای بعدی باز هم همان ۵ دقیقه را صبر کند. همچنین، در صورتی که یک پیش‌نیاز اضافه می‌شد، باید ایمیج مجددا بیلد می‌شد. در واقع با این راه حل، یک قدم به ایمیج‌های استاتیک نزدیک‌تر شدیم.

در نهایت تصمیم بر آن شد که ایمیج‌های دینامیکی کنار گذاشته شوند؛ حداقل به طور موقتی. بدین ترتیب یک ایمیج ثابت به تمام ربات‌ها ارسال می‌شود که اگرچه اندازهٔ آن از حالت اپتیمال بزرگتر است اما استفاده از آن بسیار سریع‌تر است به گونه‌ای که زمان شروع شبیه‌سازی از متوسط 5 دقیقه به حدود 1 دقیقه می‌رسد و زمان بین دو شبیه‌سازی متوالی بسیار کمتر است. لازم به ذکر است که به دلیل استفاده از  کامپوننت \مل{controller} (قسمت بعد را ببینید)، همچنان امکان دانلود دینامیکی پیش‌نیازها وجود دارد. در مورد پیش‌نیازهای \مل{pip} این قابلیت پیاده‌سازی نیز شده است اما پیش‌نیازهای \مل{apt} فعلا به طور استاتیکی در ایمیج قرار می‌گیرند.

\قسمت{پیاده‌سازی سرویس \مل{devices}}
سرویس \مل{devices} برای مدیریت دستگاه‌های فیزیکی طراحی شد. البته لازم به ذکر است که این سرویس به گونه‌ای طراحی شده است که می‌توان در آینده سرویس \مل{simulations} را نیز با این سرویس ادغام نمود. این کار در حال حاضر اولویت ندارد زیرا هر دو سرویس به طور مطلوبی کار می‌کنند.

برای استفاده از این سرویس، کاربر ابتدا ربات خود را در ابر ثبت می‌کند. پس از این کار، به ربات کاربر یک توکن تعلق می‌گیرد. کاربر با وارد کردن توکن در ربات و اجرای ایمیج داکر \مل{cakerobotics/crl-dev} می‌تواند ربات را به ابر متصل کند. توکن در قالب یک متغیر محیطی (\مل{Environment Variable}) به ربات داده می‌شود.

پس از اینکه ایمیج داکر با توکن صحیح در ربات اجرا شد، ربات خود را به سوکت سرویس \مل{devices} متصل می‌کند. سرور پس از اعتبار سنجی توکن اتصال، ربات را شناسایی کرده و سوکت آن را نگهداری می‌کند. بدین ترتیب یک کانال اتصال دائمی بین ربات و ابر به وجود می‌آید و نیازی هم به داشتن \مل{ip} ثابت برای ربات نیست.

برای تعیین آنلاین بودن یا نبودن ربات، کدی نوشته شد که وضعیت اتصال سوکت را بررسی کند. همچنین از سوکت برای ارسال دستورات کنترلی ربات شامل \مل{restart}، \مل{stop} استفاده شد. در طرف ربات نیز کامپوننتی تحت عنوان \مل{controller} اضافه شد که وظیفه پاسخ دادن به این دستورات را بر عهده دارد. برای به روزرسانی کد ربات کافی است ابتدا کد ربات موجود در ابر آپدیت شود و سپس درخواست \مل{restart} به ربات ارسال شود. کنترلر به طور خودکار کد جدید را از ابر دریافت کرده و اجرا می‌کند.

همچنین امکان ارسال دستورات سفارشی کاربر در پنل وجود خواهد داشت. این قابلیت هنوز پیاده‌سازی نشده است اما وجود آن می‌تواند تجربه کاربری بسیار خوبی را رقم بزند. برای مثال، کد زیر را در نظر بگیرید:
\begin{python}
@cake.cloud.on('get_home')
def on_get_home():
	cake.robot.navigation.move_to(0, 0)
\end{python}
اگر در کنار این کد، در محیط وب یک فیلد متن برای ارسال دستورات قرار گیرد، کاربر می‌تواند به آسانی دستورات را از طریق اینترنت به ربات منتقل کند. البته عمیق شدن در پیاده‌سازی این قابلیت از ماموریت هسته دور است و برای کاربردهای پیشرفته‌تر باید کاربر خودش از قابلیت‌های دیگر موجود در پایتون استفاده نموده و سرویس ابری خود را ایجاد کند.

در نهایت سرویس \مل{devices} روی یک رسپبری‌پای تست شد و عملکرد مطلوب دریافت شد. دو نکته در این تست عملی جلب توجه کرد. اول اینکه حجم ایمیج \مل{crl-dev} بالاست و باید دستگاه مورد نظر حداقل ۸ گیگابایت استوریج داشته باشد که البته در لحظهٔ نگارش این متن کارت حافظهٔ کوچک‌تر از ۸ گیگابایت به ندرت پیدا می‌شود. بنابراین این مشکل کم اهمیت است. البته این مشکل از طرفی نیز باعث طولانی شدن فرایند دانلود و اجرای ایمیج می‌شود. برای رفع این مشکل می‌توان به نصب دینامیک پیش‌نیازهای \مل{apt} روی آورد که در قسمت قبل مطرح شد.

مشکل دوم نیز این بود که ایمیج‌های راس ۲ که ایمیج \مل{crl-dev} بر پایهٔ آن است، برای معماری \مل{arm32} تولید نمی‌شوند. بنابراین باید از بردهایی که معماری \مل{arm64} دارند مانند \مل{Raspberry Pi 4} استفاده شود. البته در ابتدا ایمیج‌ها توسط \مل{Github Actions} و فقط برای معماری \مل{x86\_64} تولید می‌شدند. تست روی رسپبری‌پای باعث شد این نقص خود را نشان دهد و در نتیجه با استفاده از فناوری \مل{QEMU}، بیلدهای \مل{arm64} اضافه شود.

\قسمت{اضافه نمودن \مل{ros1\_bridge}}
از آنجایی که بسیاری از پروژه‌های فعلی از \مل{ROS 1} استفاده می‌کنند ولی کتابخانهٔ ما (\مل{crl}) بر پایهٔ \مل{ROS 2} است، قابلیت \مل{bridge} به ایمیج داکر اضافه شد. بدین ترتیب، در صورتی که در فایل \مل{props}، کلید \مل{ros1\_port} وجود داشته باشد، سرویس \مل{ros1\_bridge} نیز اجرا می‌شود. این قابلیت در یک رسپبری‌پای با موفقیت تست شد.

\قسمت{به‌روزرسانی مستندات آنلاین}
تغییرات اخیر کتابخانهٔ \مل{crl} در مستندات آنلاین آن که در روزهای اول نوشته شده بودند منعکس شد.
\end{document}
