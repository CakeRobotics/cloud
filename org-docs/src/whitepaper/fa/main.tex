\documentclass{cake-classes/short-report-fa}
\newcommand{\کیک}{مجموعهٔ کیکْ روباتیک}
\begin{document}
\درج‌عنوان‌سند

\قسمت{مقدمه}

فناوری روباتیک بعد از زمانی طولانی در حال انتقال از محیط آکادمیک به محیط صنعتی است.
برای نمونه، پیش‌بینی می‌شود که تعداد روبات‌های چرخ‌دار زمینی در طول دو تا سه سال آینده، 10 برابر افزایش خواهد داشت که بخش اعظم این روبات‌ها در صنعت ساخت و تولید به کار گرفته خواهند شد. \مرجع{RogerBarga2020}

کاربردهای گوناگون روبات‌ها در صنعت، طیف وسیعی از مقیاس‌ها را شامل می‌شود. در مقیاس تولید انبوه، طراحی روبات‌ها با هدف تولید تعداد زیادی نمونه یکسان انجام می‌شود.
مثال‌هایی این نوع روبات‌ها شامل روبات‌های تحویل پستی\پانویس{Last mile delivery}، روبات‌های زنجیرهٔ تامین\پانویس{Retail robots} و روبات‌های خانگی\پانویس{Household robots} می‌باشند.

در انتهای دیگر طیف، کاربردهایی هستند که در آن‌ها روبات‌هایی با امکانات کامل نیاز است اما تعداد این روبات‌ها در حدود 10 نمونه و حتی کمتر خواهد بود.
ممکن است تصور شود چنین کاربردهایی نادرتر هستند اما خلاف این امر صادق است.
برای مثال، تقریبا در تمام کارخانه‌های ساخت و تولید این مطلب صادق است که جایگزین کردن یک نیروی انسانی با روبات مسالهٔ‌ای یکتاست و به طراحی یکتا نیاز دارد ---زمان طراحی این کارخانه‌های قدیمی، سازگاری با روبات‌هایی استاندارد مد نظر نبوده است.

در قسمتی از طیف که روبات‌ها برای تولید انبوه طراحی می‌شوند، شرکت‌ها می‌توانند از عهدهٔ مخارج یک تیم خبره، شامل متخصصان طراحی، برنامه‌نویسی و تولید بر آیند.
چنین کاری برای پروژه‌هایی با مقیاس کوچک‌تر ممکن نیست.
یک کسب و کار کوچک تنها در صورتی می‌تواند از مزایای روبات‌های سفارشی شده استفاده کند که طراحی این روبات‌ها مقرون به صرفه باشد.
به طور خلاصه می‌توان گفت که در پروژه‌هایی با مقیاس بالا، تولید محصول هزینه‌ٔ غالب است اما در پروژه‌هایی با مقیاس پایین، طراحی آن هزینهٔ غالب می‌باشد.

امروزه، روبات‌های با تولید انبوه راه خود را به بازار پیدا کرده‌اند و آیندهٔ خوبی در پیش دارند. با این حال، برای روبات‌های با تولید محدود فضا متفاوت است. یک عامل مهم این امر، به نظر نویسنده، هزینهٔ طراحی می‌باشد. در ادامه، این مطلب با ذکر یک مثال قابل لمس شرح داده شده است.

\قسمت{مشکل}

یک کارخانهٔ تولیدی کوچک را در نظر بگیرید که توسط تعدادی مهندس مکانیک اداره می‌شود.
این افراد، بهترین کسانی هستند که می‌توانند تشخیص دهند که برای کدام فعالیت جایگزینی نیروی کار انسانی با روبات دارای اولویت است.
همچنین، با توجه به دانش مکانیکی این افراد و وجود قطعات الکترونیکی ساده در بازار (مانند رسپبری‌پای\پانویس{Raspberry Pi})، این افراد احتمالا می‌توانند سخت‌افزار روبات خود را نیز آماده کنند.
اما هنگامی که نوبت به نرم‌افزار می‌رسد، کار دشوار می‌شود.

امروزه حتی ساده‌ترین پلتفرم‌های روباتیک نیز به گونه‌ای هستند که استفاده از آن‌ها برای افرادی که دانش نرم‌افزاری قابل توجهی ندارند آسان نیست.
پروژه‌هایی مانند \مل{ROS} پیشرفت بسیار زیادی در این زمینه به وجود آورده‌اند اما تجربه نشان داده است که حتی نصب \مل{ROS} می‌تواند برای یک دانشجوی مکانیک تا یک ماه سردرگمی داشته باشد.
اینگونه نیست که این افراد با برنامه‌نویسی عمومی آشنا نباشند ---آن‌ها به طور مرتب از متلب\پانویس{MATLAB} استفاده می‌کنند و در عرض چند دقیقه اولین برنامهٔ آردویینوی\پانویس{Arduino} خود را نوشته‌اند.
مساله این است که بیشتر این افراد تجربهٔ زیادی در زمینهٔ لینوکس یا \مل{C++} ندارند و مشکلات آن‌ها با این سوال شروع می‌شود که «\مل{CMake} چیست؟» یا حتی، «لینوکس چیست؟».

فضای کنونی روباتیک بسیار شبیه فضای الکترونیک پیش از آردویینو است. دانش مورد نیاز برای برنامه‌ریزی یک تراشهٔ کوچک در آن زمان بسیار بیشتر از امروزه بود. هدف مجموعه پروژه‌های ما که فعلا با نام «\کیک»\پانویس{Cake Robotics} از آن یاد خواهیم کرد، این است که تا حد امکان نقش آردویینوی روباتیک را در بر گیرد. راه‌حل پیشنهاد شده توسط \کیک\ در ادامه در قالب یک سناریوی فرضی آمده است.

\قسمت{راه‌حل}

تصور کنید یک روبات با این وظیفه طراحی می‌شود که در یک اتاق بگردد و یک نماد ضربدر قرمز رنگ که روی یکی از اشیاء اتاق نصب شده است را پیدا کند.
سپس این روبات باید محل ضربدر را گزارش کند و به مکان اولیهٔ خود بازگردد.
روبات باید بتواند هر زمان که لازم باشد به محل ضربدر بازگردد، بدون اینکه لازم باشد مرحلهٔ جستجو دوباره انجام شود.
این وظیفه یک «\مل{Hello World}» مفصّل روباتیک است که عملیات نقشه‌برداری\پانویس{Mapping}، مکان‌یابی\پانویس{Navigation}، طراحی مسیر\پانویس{Path planning} و پردازش تصویر\پانویس{Image processing} را شامل می‌شود.

در این سناریو، فرد که ساخت روبات را بر عهده دارد، سخت‌افزار روبات خود را با استفاده از یک رسپبری‌پای، یک دوربین و چند چرخ با فرمان‌دهی دیفرانسیلی اسمبل می‌کند.
سپس، این فرد یک ایمیج \مل{CakeOS} را دانلود کرده و آن را روی کارت حافظهٔ \مل{MicroSD} ریخته و درون رسپبری‌پای قرار می‌دهد.
برد رسپبری‌پای بوت شده و به طور خودکار به سرویس ابری وصل می‌شود.
کاربر از طریق یک وب اپلیکیشن وارد حساب کاربری خود شده و مشاهده می‌کند که روبات در لیست دستگاه‌های او ظاهر شده است.\پانوشت{ساختار بوت گرم از پروژهٔ \مل{Balena Cloud} اقتباس شده است.}

سپس کاربر از طریق همان وب اپلیکیشن، وارد صفحهٔ مربوط به برد می‌شود و یک ویراستار کد (\مل{IDE})‌ باز می‌شود.\پانوشت{پروژهٔ \مل{AWS RoboMaker} نیز یک \مل{IDE} در مرورگر ارائه می‌دهد.} کاربر کدی مانند کد زیر را وارد می‌کند:

\pythonfromfile{sample-code.py}

مشاهده می‌شود که یک کد پایتون ساده برای توصیف وظیفهٔ روبات کافی است.
شخص پس از اینکه کد را وارد کرد، روی دکمهٔ بارگذاری کلیک می‌کند و سرویس ابری \کیک\ شروع به کار می‌کند:
کد پایتون با تمام پیش‌نیازها همراه شده (که احتمالا بر پایهٔ \مل{ROS} خواهند بود)، و در قالب یک داکر ایمیج\پانویس{Docker image} به روبات فرستاده می‌شود.
روبات بلافاصله پس از دریافت ایمیج جدید، ریستارت شده و وظیفه را آغاز می‌کند.
وضعیت روبات و خروجی‌های آن به طور پیوسته در ابر بارگذاری می‌شود.

همچنین، از آنجایی که در خط 15 کد، تعریف شده است که اطلاعات نقشهٔ اتاق در ابر ذخیره شود، روبات به طور پیوسته نقشهٔ اتاق را با ابر همگام می‌کند.
در خط 16، کلید مربوط به اتاق تعریف شده است.
می‌توان به روبات‌های دیگر اجازهٔ دسترسی به این کلید را داد تا اطلاعات اتاق را در اختیار آن‌ها نیز قرار داد.
بدین ترتیب، اشتراک اطلاعات در محیط ابری انجام می‌شود، بدون اینکه پیچیدگی اضافی به کد طراح روبات تحمیل شود.

مشاهده می‌شود که بدون وجود \کیک، پیاده‌سازی چنین روباتی بسیار دشوارتر خواهد بود.
مجددا توجه شود که \مل{ROS} پیشرفت زیادی در این راستا به وجود آورده است، اما همچنان یک لایهٔ انتزاعی دیگر می‌تواند روی \مل{ROS} اضافه شود.
همچنین، در \مل{ROS} کمتر به سرویس‌های ابری یکپارچه پرداخته شده است.

ممکن است این اشکال مطرح شود که تعریف یک لایهٔ انتزاعی روی \مل{ROS} باعث می‌شود که عمومیت، سرعت اجرای کد و کنترل برنامه‌نویس روی سخت‌افزار محدود شود.
این ادعا درست است اما تجربه نشان داده است که فواید یک لایهٔ انتزاعی می‌تواند بیشتر از معایب آن باشد:
زبان \مل{C} بر پایهٔ اسمبلی ساخته شده است و در لایهٔ بالاتر، جاواسکریپت خود بر پایهٔ \مل{C} است. امروزه حتی فریمورک‌هایی وجود دارند که به جاواسکریپت کامپایل می‌شوند. در گذشته ادعای مشابهی علیه زبان‌های سطح بالا وجود داشت که امروزه منسوخ شده است. وضعیت مشابهی برای پلتفرم‌های روباتیک نیز قابل تصور است.

\قسمت{پیشنهادها}

در نهایت، پیشنهاد می‌شود که اصول طراحی زیر برای \کیک\ به کار گرفته شود:

\شروع{فقرات}
\فقره متن-باز: حجم کد کتابخانه‌ای که برای موارد استفادهٔ گوناگون لازم است به گونه‌ای است که پیاده‌سازی آن توسط یک سازمان ممکن نخواهد بود. بنابراین، \کیک\ باید متن-باز و مشارکت-باز باشد.\پانوشت{مشارکت-باز (\مل{Open-contribution}) زیر مجموعه‌ای از متن-باز است و به این معناست که مالک نرم‌افزار علاوه بر انتشار کد آن، مشارکت‌های عمومی را نیز به کد اضافه نماید.}
\فقره استفادهٔ آسان: محصولات \کیک\ باید برای استفادهٔ آسان توسط افراد غیر نرم‌افزاری طراحی شود. این اصل باید بر عمومیت، سرعت اجرای کد، کنترل برنامه‌نویس و... مقدم شمرده شود.
\فقره ابری: تجربه نشان داده است که روبات‌هایی که از فناوری ابری استفاده می‌کنند از جهات متعددی از روبات‌های معمولی برتر هستند. بنابراین، برای اینکه یک سرویس روباتیک رقابتی باقی بماند لازم است فناوری ابری در خدماتی که می‌توانند از آن بهره بگیرند ارائه شود.
\فقره مستندات در مرحلهٔ اول: از آنجایی که تجربهٔ کاربران در اولویت اول است، باید به ازای تمام خدماتی که به دست کاربر می‌رسد مستندات، راهنما و مطالب آموزشی وجود داشته باشد. بنابراین نگارش مستندات کاربر و توسعه کد باید به طور همگام انجام شوند.
\فقره چابک\پانویس{Agile}: برنامه‌ریزی کمتر، انتشار سریع، دریافت بازخورد، تکرار.

\پایان{فقرات}

\درج‌مراجع{\bibliography{ref}}
\end{document}
